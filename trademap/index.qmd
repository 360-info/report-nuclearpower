---
# omit title and subtitle if you're doing a custom title block
# for social previews
pagetitle: Nuclear trade
description: A description for social previews
twitter-card:
  site: "@360info_global"
  image: "/folder/example.png"
open-graph:
  image: "/folder/example.png"
resources:
  - /data/nuclear-commodity-centroids.csv
  - /data/nuclear-commodity-data-allyears2023.csv
  - example.png
  - /assets/tiles/*
  - /assets/tiles/*/*/*.pbf
  - /assets/font/*
  - /assets/font/*/*
  - style.json
format:
  360-embed-html:
    css: map.css
# metadata for modals and embed sharing functionality
360embed:
  byline: James Goldie, 360info
  data-source: European Commission, Nigel Marks
  type: map
  aspect-ratio: 10 / 9
  min-height: 350px
  max-height: 900px
  bg-colour: white
  title: "Map: Nuclear trade"
  repo: report-example
  domain: https://nuclearenergy.360visuals.org
  path: /trademap/  
  fragments:
  about: |
    The data in this map comes from the [Nuclear Trade Atlas](https://data.jrc.ec.europa.eu/dataset/1cbbf606-7ca0-43a6-abce-dbd37094a092) dataset produced by the [European Commission's Joint  Research Centre](https://ec.europa.eu/info/departments/joint-research-centre).<br>

    Commodities were classified into stages of the nuclear energy lifecycle with the help of Associate Professor [Nigel Marks](https://staffportal.curtin.edu.au/staff/profile/view/nigel-marks-a3025073/) from Curtin University.<br>

    Commodities traded in each category may (but do not necessarily) include:<br>

    **Mining:** Natural uranium; and thorium ores and concentrates.<br>
    
    **Fuel fabrication:** Fuel elements, non-irradiated; magnesium, high purity; and zirconium.<br>
    
    **Enrichment:** Depleted uranium - thorium; enriched uranium - plutonium; and machinery and apparatus for isotopic separation.<br>
    
    **Power Plant:** Nickel powder; heavy water; and nuclear reactors and parts.<br>
    
    **Spent Fuel / High-Level Waste (HLW):** Irradiated fuel elements.<br>

    Some items from the trade atlas were discarded as they were ruled more likely to be related to fusion.
---

::::{#title-block-header}

:::{.header}

```{ojs}
html`<h1><span style="color: white; padding-inline: 0.2em; border-radius: 0.3em; background-color: ${colorSchemes[selectedCategory][sourceIndex]};">Suppliers</span> and <span style="color: ${colorSchemes[selectedCategory][targetIndex]};">recipients</span></h1>`

md`of nuclear power ${selectedCategory.toLowerCase()} commodities`
```

:::

:::{.detail}

```{ojs}
mutable selectedTransfer = md`No transfer selected`
mutable selectedValue = md``

// md`${transfer}: ${value}`
```

:::

::::
 
```{ojs}
//| label: setup
r = require.alias({
  maplibregl: "maplibre-gl@2.1.9/dist/maplibre-gl.js",
  h3: {},
  deck: "deck.gl@8.9.35/dist.min.js"
})

maplibregl = r("maplibregl").catch(() => window["maplibregl"])
deck = r("deck")

import { aq, op } from "@uwdata/arquero"
```
 
```{ojs}
//| label: load-filter-data
centroids = aq.loadCSV("/data/nuclear-commodity-centroids.csv")
allData = aq.loadCSV("/data/nuclear-commodity-data-allyears2023.csv")

// filter out ignored commodities, then join sources/recipients with centroids
mergedData = allData
  .filter(d => d.category != "Ignore")
  .join(centroids,
    ["source_iso3", "iso3"],
    [[aq.all()], ["iso3", "lat", "lon"]],
    {
      suffix: ["", "_source"]
    })
  .join(centroids,
    ["recipient_iso3", "iso3"],
    [[aq.all()], ["iso3", "lat", "lon"]],
    {
      suffix: ["", "_recipient"]
    })
  .objects()
``` 

```{ojs}
//| label: category-filter
viewof selectedCategory = Inputs.radio(
  Array.from(new Set(mergedData.map(d => d.category))), {
    value: "Mining",
    format: x => html`<span style="color: ${colorSchemes[x][3]}">${x}</span>`
  }
)

viewof selectedCountry = Inputs.text({ 
  placeholder: "Country name" });

// filter displayed data based on both category and countries
categoryData = mergedData.filter(d =>
  d.category == selectedCategory &&
  (d.source.toLowerCase().includes(selectedCountry.toLowerCase()) ||
    d.recipient.toLowerCase().includes(selectedCountry.toLowerCase())))
```

```{ojs}
//| label: scales
// width and opacity are both scaled logarithmically to help mid values stand
// out. (note / 6 to express sum_value_usd as avg. across 6 years)
valueExtent = d3.extent(mergedData.map(d => d.sum_value_usd / 6))
widthScale =
  d3.scaleLog()
  .domain(valueExtent)
  .range([0.25, 2.5])
opacityScale =
  d3.scaleLog()
  .domain(valueExtent)
  .range([
    opacities[selectedCategory] * 0.15 * 255,
    opacities[selectedCategory] * 255])

// we'll use a different colour scale for each category, taking a different lightness for source and recipient
colorSchemes = ({
  "Mining": d3.schemeYlOrBr[9],
  "Enrichment": d3.schemeYlGn[9],
  "Fuel fabrication": d3.schemeYlGnBu[9],
  "Power Plant": d3.schemeGreys[9],
  "Spent Fuel / HLW": d3.schemeRdPu[9]
})
sourceIndex = 7
targetIndex = 1
 
opacities = ({
  "Mining": 0.55,
  "Enrichment": 0.3,
  "Fuel fabrication": 0.3,
  "Power Plant": 0.3,
  "Spent Fuel / HLW": 0.7
})

// convert hexcode into deckgl's [r, g, b] format @ 25% opacity
convertSchemeToDeck = (category) => {
  return colorSchemes[category]
    .map(d => d3.color(d))
    .map(d => [d.r, d.g, d.b])
}
deckColorScheme = convertSchemeToDeck(selectedCategory)
defaultScheme = convertSchemeToDeck("Mining")

```

```{ojs}
//| label: arc-layer
transferArcs = new deck.MapboxLayer({
  id: "transferArcs", 
  type: deck.ArcLayer,
  data: [],
  getSourcePosition:
    d => [Number(d.lon), Number(d.lat)],
  getTargetPosition:
    d => [Number(d.lon_recipient), Number(d.lat_recipient)],
  getWidth: d => widthScale(d.sum_value_usd / 6),
  getTilt: d => Number(d.lon) > Number(d.lon_recipient) ? 0 : -5,
  pickable: true,
  autoHighlight: true,
  highlightColor: [255, 200, 0, 255]
})
```

```{ojs}
//| label: map

viewof map = {
  let container = html`<div></div>`;

  yield container;

  // Create the \`map\` object with the mapboxgl.Map constructor, referencing
  // the container div
  let map = new maplibregl.Map({
    container,
    bounds: [[-175, -80], [175, 85]],
    pitch: 30,
    antialias: true,
    style: "style.json",
    attribution: false
  });

  map.on("load", () => {

    // dispatch back to ojs
    container.value = map;
    container.dispatchEvent(new CustomEvent("input"));
    
    map.addLayer(transferArcs);

    // on arc hover, update the title text
    // (note that si suffix swap giga => billions)
    transferArcs.setProps({
      onHover: (info) => {
        if (info && info.object) {
          const amountText =
            d3.format("$.2s")(info.object.sum_value_usd)
              .replace("G", "B")
              .replace("P", "T")
          mutable selectedTransfer =
            md`${info.object.source} → ${info.object.recipient}`
          mutable selectedValue =
            html`US${amountText} / year <span class="small">average over 2016–2021</span>`
        } else {
          mutable selectedTransfer = md`No transfer selected`
          mutable selectedValue = md``
        }
      }
    })

    // also configure the automatically-create deck instance
    transferArcs.deck.setProps({ pickingRadius: 10 });

  })

}
```

```{ojs}
//| label: update-arcs
updates = transferArcs.setProps({
  data: categoryData,
  getSourceColor: d => [...deckColorScheme[sourceIndex], opacityScale(d.sum_value_usd)],
  getTargetColor: d => [...deckColorScheme[targetIndex], opacityScale(d.sum_value_usd)]
})
```


{{< include _popups/_buttons.qmd >}}

{{< include _popups/_dialogs.qmd >}}
