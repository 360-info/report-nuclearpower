---
# omit title and subtitle if you're doing a custom title block
# for social previews
pagetitle: Nuclear trade
description: Producing nuclear energy requires more than just fuel. See the flow of nuclear materials across the globe in this map.
twitter-card:
  site: "@360info_global"
  image: "/folder/example.png"
open-graph:
  image: "/folder/example.png"
resources:
  - /data/nuclear-commodity-centroids.csv
  - /data/nuclear-commodity-data-allyears2023.csv
  - example.png
  - /assets/tiles/*
  - /assets/tiles/*/*/*.pbf
  - /assets/font/*
  - /assets/font/*/*
  - style.json
format:
  360-embed-html:
    css: map.css
# metadata for modals and embed sharing functionality
360embed:
  byline: James Goldie, 360info
  data-source: European Commission, Nigel Marks
  type: map
  aspect-ratio: 10 / 9
  min-height: 350px
  max-height: 900px
  bg-colour: white
  title: "Map: Nuclear trade"
  repo: report-nuclearpower
  domain: https://nuclearenergy.360visuals.org
  path: /trademap/  
  fragments:
  about: |
    The data in this map comes from the [Nuclear Trade Atlas](https://data.jrc.ec.europa.eu/dataset/1cbbf606-7ca0-43a6-abce-dbd37094a092){target="_blank"} dataset produced by the [European Commission's Joint  Research Centre](https://ec.europa.eu/info/departments/joint-research-centre){target="_blank"}.<br>

    Commodities were classified into stages of the nuclear energy lifecycle with the help of Associate Professor [Nigel Marks](https://staffportal.curtin.edu.au/staff/profile/view/nigel-marks-a3025073/){target="_blank"} from Curtin University.<br>

    Commodities traded in each category may (but do not necessarily) include:<br>

    **Mining:** Natural uranium; and thorium ores and concentrates.<br>
    
    **Fuel fabrication:** Fuel elements, non-irradiated; magnesium, high purity; and zirconium.<br>
    
    **Enrichment:** Depleted uranium - thorium; enriched uranium - plutonium; and machinery and apparatus for isotopic separation.<br>
    
    **Power Plant:** Nickel powder; heavy water; and nuclear reactors and parts.<br>
    
    **Spent Fuel / High-Level Waste (HLW):** Irradiated fuel elements.<br>

    Some items from the trade atlas were discarded as they were ruled more likely to be related to fusion.
---

::::{#title-block-header}

:::{.header}

```{ojs}
html`<h1><span style="color: white; padding-inline: 0.2em; border-radius: 0.3em; background-color: ${colorSchemes[selectedCategory][sourceIndex]};">Suppliers</span> and <span style="color: ${colorSchemes[selectedCategory][targetIndex]};">recipients</span></h1>`

md`of nuclear power ${selectedCategory.toLowerCase()} commodities`
```

:::

:::{.detail}

```{ojs}
//| label: statsCalc
//| output: false

// these are updated by deck on arc hover
mutable selectedSource = null
mutable selectedRecipient = null
mutable selectedValue = null

// calculate totals for text display based on selected source and recipient

sourceTotalOut = d3.sum(
  categoryData
    .filter(d => d.source == selectedSource)
    .map(d => d.sum_value_usd))
sourceTotalIn = d3.sum(
  categoryData
    .filter(d => d.recipient == selectedSource)
    .map(d => d.sum_value_usd))

recipientTotalOut = d3.sum(
  categoryData
    .filter(d => d.source == selectedRecipient)
    .map(d => d.sum_value_usd))
recipientTotalIn = d3.sum(
  categoryData
    .filter(d => d.recipient == selectedRecipient)
    .map(d => d.sum_value_usd))

// currency formatter
money = function(x) {
  return "US" +
    d3.format("$.0s")(x)
      .replace("G", "B")
      .replace("P", "T")
}

```

```{ojs}
//| label: statsText

mutable selectedTransfer = selectedSource && selectedRecipient ?
  html`${selectedSource} → ${selectedRecipient}: ${money(selectedValue)}<br><br>` :
  md`No transfer selected`

selectedSource && selectedRecipient ?
  md`#### Globally` :
  md``

mutable sourceTotals = selectedSource && selectedRecipient ?
  html`<strong>${selectedSource}:</strong> ${money(sourceTotalIn)} imported, ${money(sourceTotalOut)} exported` :
  md``

mutable recipientTotals = selectedSource && selectedRecipient ?
  html`<strong>${selectedRecipient}:</strong> ${money(recipientTotalIn)} imported, ${money(recipientTotalOut)} exported` :
  md``

selectedSource && selectedRecipient ?
  html`<span class="small">totals over 2016–2021</span>` :
  md``

```

:::

::::
 
```{ojs}
//| label: setup
r = require.alias({
  maplibregl: "maplibre-gl@2.1.9/dist/maplibre-gl.js",
  h3: {},
  deck: "deck.gl@8.9.35/dist.min.js"
})

maplibregl = r("maplibregl").catch(() => window["maplibregl"])
deck = r("deck")

import { aq, op } from "@uwdata/arquero"
```
 
```{ojs}
//| label: load-filter-data
centroids = aq.loadCSV("/data/nuclear-commodity-centroids.csv")
allData = aq.loadCSV("/data/nuclear-commodity-data-allyears2023.csv")

// filter out ignored commodities, then join sources/recipients with centroids
mergedData = allData
  .filter(d => d.category != "Ignore")
  .join(centroids,
    ["source_iso3", "iso3"],
    [[aq.all()], ["iso3", "lat", "lon"]],
    {
      suffix: ["", "_source"]
    })
  .join(centroids,
    ["recipient_iso3", "iso3"],
    [[aq.all()], ["iso3", "lat", "lon"]],
    {
      suffix: ["", "_recipient"]
    })
  .objects()
``` 

```{ojs}
//| label: category-filter
viewof selectedCategory = Inputs.radio(
  ["Mining", "Enrichment", "Fuel fabrication", "Power Plant", "Spent Fuel / HLW"], {
    value: "Mining",
    format: x => html`<span style="color: ${colorSchemes[x][3]}">${x}</span>`
  }
)

viewof selectedCountry = Inputs.text({ placeholder: "Country name" })

// filter displayed data based on both category and countries
categoryData = mergedData.filter(d =>
  d.category == selectedCategory &&
  (d.source.toLowerCase().includes(selectedCountry.toLowerCase()) ||
    d.recipient.toLowerCase().includes(selectedCountry.toLowerCase())))
```

```{ojs}
//| label: scales
// width and opacity are both scaled logarithmically to help mid values stand
// out
valueExtent = d3.extent(mergedData.map(d => d.sum_value_usd))
widthScale =
  d3.scaleLinear()
  .domain(valueExtent)
  .range([0.5, 3.5])

// we'll use a different colour scale for each category, taking a different lightness for source and recipient
colorSchemes = ({
  "Mining": d3.schemeYlOrBr[9],
  "Enrichment": d3.schemeYlGn[9],
  "Fuel fabrication": d3.schemeYlGnBu[9],
  "Power Plant": d3.schemePuBu[9],
  "Spent Fuel / HLW": d3.schemeRdPu[9]
})
sourceIndex = 6
targetIndex = 2
 
opacities = ({
  "Mining": 0.55,
  "Enrichment": 0.3,
  "Fuel fabrication": 0.3,
  "Power Plant": 0.3,
  "Spent Fuel / HLW": 0.7
})

// convert hexcode into deckgl's [r, g, b] format @ 25% opacity
convertSchemeToDeck = (category) => {
  return colorSchemes[category]
    .map(d => d3.color(d))
    .map(d => [d.r, d.g, d.b])
}
deckColorScheme = convertSchemeToDeck(selectedCategory)
defaultScheme = convertSchemeToDeck("Mining")

```

```{ojs}
//| label: arc-layer
transferArcs = new deck.MapboxLayer({
  id: "transferArcs", 
  type: deck.ArcLayer,
  data: [],
  getSourcePosition:
    d => [Number(d.lon), Number(d.lat)],
  getTargetPosition:
    d => [Number(d.lon_recipient), Number(d.lat_recipient)],
  getWidth: d => widthScale(d.sum_value_usd),
  getTilt: d => Number(d.lon) > Number(d.lon_recipient) ? 0 : -5,
  pickable: true,
  autoHighlight: true,
  highlightColor: [255, 200, 0, 255]
})
```

```{ojs}
//| label: map

viewof map = {
  let container = html`<div></div>`;

  yield container;

  // Create the \`map\` object with the mapboxgl.Map constructor, referencing
  // the container div
  let map = new maplibregl.Map({
    container,
    bounds: [[-175, -80], [175, 85]],
    pitch: 30,
    antialias: true,
    style: "style.json",
    attribution: false
  });

  map.on("load", () => {

    // dispatch back to ojs
    container.value = map;
    container.dispatchEvent(new CustomEvent("input"));
    
    map.addLayer(transferArcs);

    // on arc hover, update the title text
    // (note that si suffix swap giga => billions)
    transferArcs.setProps({
      onHover: (info) => {
        if (info && info.object) {
          // const amountText = 
          //   d3.format("$.2s")(info.object.sum_value_usd)
          //     .replace("G", "B")
          //     .replace("P", "T")
          mutable selectedSource = info.object.source
          mutable selectedRecipient = info.object.recipient
          // mutable selectedTransfer =
          //   md`${info.object.source} → ${info.object.recipient}`
          mutable selectedValue = info.object.sum_value_usd
            // html`US${amountText} / year <span class="small">average over 2016–2021</span>`
        } else {
          mutable selectedSource = null
          mutable selectedRecipient = null
          mutable selectedValue = null
        }
      }
    })

    // also configure the automatically-create deck instance
    transferArcs.deck.setProps({ pickingRadius: 10 });

  })

}
```

```{ojs}
//| label: update-arcs
updates = transferArcs.setProps({
  data: categoryData,
  getSourceColor: d =>
    [...deckColorScheme[sourceIndex], opacities[selectedCategory] * 255],
  getTargetColor: d =>
    [...deckColorScheme[targetIndex], opacities[selectedCategory] * 255]
})
```


{{< include _popups/_buttons.qmd >}}

{{< include _popups/_dialogs.qmd >}}
